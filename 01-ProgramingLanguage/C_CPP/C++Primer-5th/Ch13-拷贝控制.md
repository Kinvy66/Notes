# 第13章 拷贝控制





一个类通过定义五种特殊的成员函数来控制对象拷贝、移动、赋值和销毁的操作，包括：**拷贝构造函数**、**拷贝赋值运算符**、**移动构造函数**、**移动赋值运算符** 和 **析构函数**，这些操作称为 **拷贝控制操作**。如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。有时编译器定义的默认操作可能并不满足我们的要求，而需要显式的重新定义某些操作。本章将详细介绍每个操作的细节。



## 1.  拷贝、赋值与销毁

以最基本的操作——拷贝构造函数、拷贝赋值运算符和析构函数作为开始。



### 1.1 拷贝构造函数

如果一个构造函数的<span style="background: yellow">第一个参数是自身类类型的引用，且其他额外的参数都有默认值</span>，则此构造函数是**拷贝构造函数**。

```cpp
class Foo {
public:
    Foo();		// 默认构造函数
    Foo(const Foo& );  // 拷贝构造函数
    // ...
};
```

拷贝函数的注意：

- 拷贝函数的第一个参数必须是引用类型（后面解释为什么）
- 第一个参数一般情况下都是定义为 `const`
- 拷贝函数会被隐式使用，所以拷贝函数通常不应该是 `explicit`

#### 合成拷贝构造函数

如果没有为一个类定义拷贝构造函数，编译器会生成一个默认的拷贝构造函数，叫做**合成拷贝构造函数**。 默认构造函数在我们定义了其他任意的构造函数编译器就不会在自动生成，但是合成拷贝构造函数不同，即使我们定义了构造函数（没有定义拷贝构造函数），编译器也会生成默认的拷贝构造函数。

以 `Sales_data` 为例，合成拷贝构造函数的操作就是进行简单的 <span style="color:red">值拷贝</span>，等价代码：

```cpp
class Sales_data {
public:
    // ...
    Sales_data(const Sales_data&);
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};
// 与 Sales_data 的合成的拷贝构造函数等价
Sales_data::Sales_data(const Sales_data &orig):
	bookNo(orig.bookNo),
	units_sold(orig.units_sold),
	revenue(orig.revenue)
    {  }
```

合成拷贝构造函数在大多数的情况下是可以满足需求的，比如 `Sales_data` 这样的类。但是在类的成员变量中有引用类型的变量（指针），那么合成拷贝构造函数会出现浅拷贝（后面会详细讲解）。



#### 拷贝初始化

直接初始化与拷贝初始化之间的差异

```cpp
string dots(10, '.');		// 直接初始化
string s(dots);				// 直接初始化
string s2 = dots;			// 拷贝初始化
string null_book = "9-999-9999-9";  // 拷贝初始化
string nines = string(100, '9');	// 拷贝初始化
```

直接初始化是调用参数匹配的普通有参构造函数，而当我们用 `=` 运算符初始化（注意，这里的 `=` 运算符是初始化而不是赋值操作）调用的是 **拷贝构造函数** （拷贝初始化），将右侧的对象拷贝到正在创建的对象，如果需要的话还要进行类型转换。拷贝初始化并不总是调用拷贝构造函数，如果一个类定义了移动构造函数，那么有可能会调用移动构造函数，关于移动构造函数的工作机制后面会详细讲解。

拷贝初始化不仅在我们用 `=` 定义变量时会发生，在下列情况也会发生

- 将一个对象作为实参传递给一个非应用类型的形参

- 从一个返回类型未非引用的函数返回一个对象

  ```cpp
  // 调用 func 会发生两次拷贝初始化操作
  // 1. 将一个 Sales_data 对象传递给形参
  // 2. 返回一个 Sales_data 对象
  Sales_data func(Sales_data item)
  {
      ret = item;
      // 对 ret 处理
      return ret;
  }
  ```

- 用花括号列表初始化一个数组种的元素或一个聚合类中的成员

  ```cpp
  // 聚合类
  struct Data {
    int ival;
    string s;
  };
  
  Data val1 = {0, "Anna"};
  ```

某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其 `insert` 或 `push` 成员（参见9.3.1节）时，容器对其元素进行拷贝初始化，用 `emplace` 成员创建的元素都进行直接初始化（参见9.3.1节）。



#### 参数和返回值

在函数调用过程中，具有非引用类型的参数和具有非引用的返回类型都有拷贝初始化。

拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们有需要调用拷贝构造函数，如此无限循环。



#### 拷贝初始化的限制

如果一个构造函数声明为 `explicit` ，那么我们就必须显式的调用

```cpp
vector<int> v1(10);		// 正确：直接初始化
vector<int> v2 = 10;	// 错误： 接受大小参数的构造函数是 explicit 的
void f(vector<int>);	// f 的参数进行拷贝初始化
f(10);			//错误： 不能用一个 explicit 的构造函数拷贝一个实参
f(vector<int>(10));		// 正确： 从一个 int 直接构造一个临时 vector
```



#### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象，即

```cpp
string null_book = "9-999-9999-9";  // 拷贝初始化
// 编译器会改写为
string null_book("9-999-9999-9"); // 编译器略过了拷贝构造函数
```

但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须存在且可访问（例如，不能是 `private` 的）。



### 1.2 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```cpp
Sales_data trans, accum;
trans = accum;	// 使用 Sales_data 的拷贝赋值运算符
```

赋值操作是调用拷贝赋值运算符，与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

> 初始化化和赋值操作都是使用 `=` ，注意区分什么时候是初始化，什么时候是赋值操作（参考第2章）。



#### 重载赋值运算符

拷贝赋值操作是通过重载 `=` 运算符来实现的，重载运算符本质上是函数，其名字由 `operator` 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 `operator=` 的函数。类似于任何其他函数，运算符也有一个返回类型和一个参数列表。

对于重载运算符的使用，如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 `this` 参数，所以，成员函数的运算符重载的参数都是比实际需要的参数少一个。比如 `=` 是一个二元运算符，定义为成员函数，只需要一个参数。

```cpp
class Foo {
public:
    Foo& operator=(const Foo& rhs);  // 赋值运算符
};
```



> 赋值运算符通常应该返回一个指向其左侧运算对象的引用。



#### 合成赋值运算符

与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**。合成的赋值运算是将右侧的对象的属性逐个赋值到左侧对象。

```cpp
// 等价于合成拷贝赋值运算符
Sales_data&
Sales_data::opertor=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo;
    units_sold = rhs.untis_sold;
    revenue = rhs.revenue;
    return *this;
}
```



#### 拷贝赋值运算符的调用

拷贝运算符的调用和我们使用 `=` 运算的操作逻辑是一样的，这一点对于其他的重载操作符也是使用的。

```cpp
Sales_data trans, accum;
trans = accum;	// 使用 Sales_data 的拷贝赋值运算符
// 等价的形式，
trans.opertor=(accum);
operator=(trans, accum);
```

上面两种等价形式，第一种是正确的代码，第二种是把 `this` 显式的传递，语法上是错误的。通常我们不会像调用函数一样使用重载运算符，而是直接使用对应的操作符。



### 1.3 析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非 `static` 数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非 `static` 数据成员。

析构函数是类的一个成员函数，名字由波浪号节类名构成。它没有返回值，也不接受参数：

```cpp
class Foo {
public:
    ~Foo();		// 析构函数
    // ...
};
```

由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只有唯一一个析构函数。



#### 析构函数完成什么工作

如同构造函数有一个初始化部分（初始化列表）和一个函数体，析构函数也有一个函数体和一个析构部分。构造函数是先执行初始化后执行函数体，析构函数是先执行函数体后执行析构部分。析构函数的函数体是有类的设计者给出，不存在类似构造函数中初始化列表的东西来控制成员的如何销毁，析构部分是隐式的。

销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

> 隐式销毁一个内置指针类型的成员不会delete它所指向的对象。

#### 什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论时标准容器还是数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当指向它的指针应用 `delete` 运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁





















