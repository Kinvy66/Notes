# 第 10 章 泛型算法



## 1. 概述

大多数算法都定义在头文件 `algorithm` 中。标准库还在头文件 `numeric` 中定义了一组数值泛型算法。

 <span style="background: yellow"> 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</span>

`find` 算法示例

```cpp
int val = 42;	// 我们将查找的值
// 如果在vec 中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()
auto result = find(vec.cbegin(), vec.cend(), val);
// 报告结果
cout << "The value " << val
    << (result == vec.cend()
       ? " is not present" : " is present") << endl;
```



#### 算法如何工作

以 `find` 为例：

1. 访问序列中的首元素。
2. 比较此元素于我们要查找的元素。
3. 如果此元素于我们要查找的值匹配，`find` 返回标识此元素的值。
4. 否则，`find` 前进到下一个元素，重复执行步骤 2 和 3。
5. 如果达到序列尾，`find` 应停止。
6. 如果 `find` 达到序列末尾，它应该返回一个指出元素未找到的值。此值和步骤 3 返回的值必须具有相容的类型。

 <span style="background: yellow"> 这些步骤都不依赖于容器所保存的元素类型。</span> 因此，只要有一个迭代器可用来访问元素， `find` 就完全不依赖于容器类型。

#### 迭代器令算法不依赖于容器，······

在上述的 `find` 函数的流程中，除了第 2 步外，其他步骤都可以用迭代器操作来实现。

#### ······，但算法依赖于元素类型的操作

虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个）元素类型上的操作。例如，在步骤 2 中，`find` 用元素类型的 `==` 运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持 `<` 运算符。不过，我们将看到，大多数算法提供了一种方法，允许我们使用自定义的操作来替代默认的运算符。



> **算法永远不会执行容器的操作**



## 2. 初始泛型算法

标准库提供了超过100个算法，这些算法都是有一致的结构，下面以几种具体的算法为例介绍标准库中算法的结构。

### 2.1 只读算法

只读算法只会读取输入范围内的元素，不改变元素。`find` 就是这样一种算法。

以 `accumulate` 为例，它定义在头文件 `numeric` 中，这个函数的功能时求和。它接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值





