# 第 10 章 泛型算法



## 1. 概述

大多数算法都定义在头文件 `algorithm` 中。标准库还在头文件 `numeric` 中定义了一组数值泛型算法。

 <span style="background: yellow"> 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</span>

`find` 算法示例

```cpp
int val = 42;	// 我们将查找的值
// 如果在vec 中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()
auto result = find(vec.cbegin(), vec.cend(), val);
// 报告结果
cout << "The value " << val
    << (result == vec.cend()
       ? " is not present" : " is present") << endl;
```



#### 算法如何工作

以 `find` 为例：

1. 访问序列中的首元素。
2. 比较此元素于我们要查找的元素。
3. 如果此元素于我们要查找的值匹配，`find` 返回标识此元素的值。
4. 否则，`find` 前进到下一个元素，重复执行步骤 2 和 3。
5. 如果达到序列尾，`find` 应停止。
6. 如果 `find` 达到序列末尾，它应该返回一个指出元素未找到的值。此值和步骤 3 返回的值必须具有相容的类型。

 <span style="background: yellow"> 这些步骤都不依赖于容器所保存的元素类型。</span> 因此，只要有一个迭代器可用来访问元素， `find` 就完全不依赖于容器类型。

#### 迭代器令算法不依赖于容器，······

在上述的 `find` 函数的流程中，除了第 2 步外，其他步骤都可以用迭代器操作来实现。

#### ······，但算法依赖于元素类型的操作

虽然迭代器的使用令算法不依赖于容器类型，但大多数算法都使用了一个（或多个）元素类型上的操作。例如，在步骤 2 中，`find` 用元素类型的 `==` 运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持 `<` 运算符。不过，我们将看到，大多数算法提供了一种方法，允许我们使用自定义的操作来替代默认的运算符。



> **算法永远不会执行容器的操作**



## 2. 初始泛型算法

标准库提供了超过100个算法，这些算法都是有一致的结构，下面以几种具体的算法为例介绍标准库中算法的结构。

### 2.1 只读算法

只读算法只会读取输入范围内的元素，不改变元素。`find` 就是这样一种算法。

以 `accumulate` 为例，它定义在头文件 `numeric` 中，这个函数的功能时求和。它接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。

```cpp
// vec 是一个整数序列
// 对 vec 中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```

>`accumulate` 的第三个参数的类型决定了函数中使用哪个加法运算符以及返回的类型



#### 算法和元素类型

`accumulate` 将第三个参数作为求和起点，这蕴含这一个编程假定： <span style="background: yellow"> 将元素类型加到和的类型上的操作必须可行。</span> 即序列中的元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型，如果类型是自定义类型，那么自定义类型必须定义 `+` 运算符。

下面两个例子

```cpp
// v 的类型是 vector<string>
string sum = accumulate(v.cbegin(), v.cend(), string(""));  // 正确
string sum = accumulate(v.cbegin(), v.cend(), "");  // 错误： const char* 上没有定义 + 运算符
```

 在第二个求和的调用中，第三个参数是字符串字面值，类型是 `const char*` ，由于 `const char*` 并没有 `+` 运算符，此调用将产生编译错误。

> 对于只读取而不改变元素的算法，通常最好使用 `cbegin()` 和 `cend()` 。如果需要改变元素则使用 `begin()` 和 `end()`。

 

#### 操作两个序列的算法

`equal` 算法，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回 `true` ， 否则返回 `false` 。此算法接受三个迭代器：前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素（指需要比较的元素范围的起始位置）

```cpp
// roster2 中的元素数目应该至少与 roster1 一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

由于 `equal` 利用迭代器完成，因此我们可以调用 `equal` 来比较两个不同类型的容器中的元素。而且元素类型也不必一样，只要我们能用 `==` 来比较两个元素类型即可（即两个类型需要有重载的 `==` 支持它们之间进行比较）。

但是，`equal` 基于一个非常重要的假设：<span style="background: yellow">它假定第二个序列至少与第一个序列一样长。</span>

> 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二序列至少与第一个序列一样长。



###  2.2写容器元素的算法

一些算法将心智赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。因为<span style="background: yellow">算法不会执行容器操作</span>，它们自身不能改变容器的大小。

算法 `fill` ，它的接受一对迭代器表示一个范围，还接受一个值作为第三个参数。 `fill` 将给定的这个值赋予输入序列中的每个元素

```cpp
fill(vec.begin(), vec.end(), 0);		// 将每个元素重置 0
// 将容器的一个子序列设置为10
fill(vec.begin()， vec.end() + vec.size()/2, 10)
```



#### 算法不检查写操作

一些算法接受一个迭代器来指出起始位置，使用一个计数值表示需要写入的个数。例如 `fill_n` 函数接受一个单迭代器、一个计数值和一个值，它的功能是从给定迭代器的位置写入 “计数值” 个数，这个数是由第三个参数给出。

```cpp
vector<int> vec;	// 空vector
// 使用 vec，赋予它不同的值
fill_n(vec.begin(), vec.size(), 0);		// 将所有元素重置为0
```

函数 `fill_n` 假定写入指定元素是安全的，即，如下形式的调用

```cpp
fill_n(dest, n, val)
```

`fill_n` 假定 dest 指向一个元素，而从 dest 开始的序列至少包含 n 个元素。

```cpp
vector<int> vec;	// 空vector
// 灾难：修改 vec 中的10个（不存在）元素
fill_n(vec.begin(), 10, 0);		
```

上面 `fill_n` 调用指定写入10 个元素，但 vec 的大小并没有 10，这条语句的结果是未定义的。

> 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素
>
> 算法并不会检查写入元素的个数，也不会自动改变容器的大小



#### 介绍 back_inserter

使用**插入迭代器**可以保证调用写入算法有足够的空间来容纳输出数据。插入迭代器是一种向容器添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值话右侧值相等的元素被添加到容器。调用`back_inserter` 即可获取到容器的插入迭代器，它定义在头文件  `iterator`

```cpp
vector<int> vec;   // 空 vector
// it 的类型为 std::back_insert_iterator<std::vector<int>>
auto it = back_inserter(vec);	// 通过它赋值会将元素添加到 vec 中
*it = 42;	// 42会添加到vec中
```

在算法中作为目的位置使用

```cpp
vector<int> vec;   // 空 vector
// 正确：back_inserter 创建一个插入迭代器，可用来向vec添加元素
fill_n(back_inserter(vec), 10, 0);	// 添加 10 个元素到 vec
```

当我们传递的是插入迭代器，每次赋值都会在 vec 上调用 `push_back` ，在容器的末尾添加元素。



#### 拷贝算法

拷贝算法是一个向目的位置迭代器指向的输出序列的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。<span style="background: yellow"> 目的序列至少要包含与输出序列一样多的元素</span>

使用 `copy` 实现内置数组的拷贝

```cpp
int a1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int a2[sizeof(a1)/sizeof(*a1)];		// a2和a1大小一样
// ret 指向拷贝到 a2 的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);	// 把 a1 的内容拷贝给 a2
```

`copy` 放回的是其目的物质迭代器（递增后）的值。即，`ret` 指向拷贝到 a2 的尾元素之后的位置。

有些算法提供所谓的 "拷贝" 版本，比如 `replace` 和 `replace_copy`  （拷贝版本）

这两个函数都是替换序列中元素的值。`replace` 接受 4 个参数： 前两个是迭代器，表示输出序列，后两个一个是要被替换的值，另一个是替换后的新值。

```cpp
// 将ilst 中所有值为 0 的元素改为 42
replace(ils.begin(), ilst.end(), 0, 42);
```

`replace` 是在原始序列上改动，而 `replace_copy` 是将改动后的序列拷贝一份，原序列保持不变。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置

```cpp
// 使用 back_inserter 按需要增长目标序列
replace_copy(ilst.cbegin(), ils.cend(),
            back_inserter(ivec), 0, 42);
```

此调用，ils 并未改变，ivec 包含 ilst 的一份拷贝，不过原来 ilst 中的值为 0 的元素在 ivec 中都变为 42。



### 2.3 重排容器元素的算法

排序算法，这类算法是利用元素类型的 `<` 运算符来实现排序的。

下面以一段文本为例，这段文本保存在 `vector` 中，我们希望简化这个 `vector` ，使得每个单词只出现一次。

```
the quick red fox jumps over the slow red turtle
```

去重排序后的 `vector`

```
fox jumps over quick red slow the turtle
```



#### 消除重复单词

```cpp
void eliDups(vector<string> &words)
{
    // 按字典排序 words ，以便查找重复单词
    sort(words.begin(), words.end());
    // unique 重排输入范围，使得每个单词只出现一次
    // 排序在范围的前部，返回指向不重复区域之后一个位置的迭代器
    auto end_unique = unique(words.begin(), words.end());
    // 使用容器操作 erase 删除重复元素
    words.erase(end_unique, words.end());
}
```

在完成 `sort` 后，`words` 的顺序如下

```
fox jumps over quick red red slow the the turtl
```



#### 使用 unique

调用 `unique` 后 `vector` 将变为：

![image-20220526151913397](https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20220526151913397.png)

`words` 的大小并没有改变，它仍有10个元素。但这些元素的顺序被改变了——相邻的重复元素被 “移动”到了最后。`unique` 返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素依然存在，但我们不知道它们的值是什么。

> 标准库算法对迭代器而不是容器进行操。因此，算法不能（直接）添加或删除元素。



#### 使用容器操作删除元素

为了删除无用的元素，我们必须使用容器操作。所有最后使用了 `erase` 删除重复的元素。







## 3. 定制操作

很多算法都会比较输出序列中的元素。默认情况下，这类算法使用元素类型的 `==` 或 `<` 运算符来完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自定义的操作来代替默认运算符。



### 3.1 向算法传递函数

对于 `elimDups` （2.3 小节）还希望单词按其长度排序，大小相同的再按字典序排列。为了实现按长度重排 `vector` ，我们可以使用 `sort` 的第二个版本，它接受第三个参加，参数是一个 **谓词**。

#### 谓词

**谓词**是一个可调用的表达式，其返回结果是一个能用作条件的值。可调用表达式是指以 ` express(args)` 这种方式调用，这里的 "可调用的表达式"可以简单的理解为就是函数指针（目前我们只知道函数和函数指针这两种可调用对象，后面章节还会介绍其他可调用对象）。

标准库算法所使用的谓词分类两类：**一元谓词**，只接受单一参数；**二元谓词**，可接受两个参数。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。

接受一个二元谓词参数的 `sort` 版本用这个谓词来代替 `<` 来比较元素。

```cpp
// 比较函数，用来按长度排序单词， 作为一个二元谓词传递给 sort
bool isShorter(const string& s1, const string& s2)
{
    return s1.size() < s2.size();
}
// 按长度有短至长排序 words
sort(words.begin(), words.end(), isShorter);
```



#### 排序算法

在我们将 `words` 按大小重排的同时，还希望具有相同长度的元素按字典序排序。为了保持相同长度的单词按字典序排序，可以使用 `stable_sort` 算法。这种稳定排序算法维持相等的元素原有顺序。

```cpp
elimDups(words);  // 将words按字典序重排，并消除重复单词
// 按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(), words.end(), isShorter);
for (const auto &s : words)
    cout << s << " ";
cout << endl;
```

输出结果：

```
fox red the over slow jumps quick turtle
```



### 3.2 lambda 表达式

根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。

一个例子，我们修改 3.1 节的程序，求大于等于一个给定长度的单词有多少，并将这些单词打印出来。

```cpp
void biggies(vector<string>& words, 
             vector<string>::size_type sz)
{
    elimDups(words);  // 将words按字典序重排，并消除重复单词
    // 按长度重新排序，长度相同的单词维持字典序
	stable_sort(words.begin(), words.end(), isShorter);
    // 1. 获取一个迭代器，指向第一个满足 size() >= sz 的元素
    // 2. 计算满足 size() >= sz 的元素的数目
    // 3. 打印
 }
```

在步骤1，我们科室使用标准库 `find_if` 算法来查找第一个具有特定大小的元素。`find_if` 算法接受一对迭代器，表示一个范围，第三个参数是一个谓词。`find_if` 算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0值得元素，如果不存在这样得元素，则返回尾迭代器。

编写一个函数，令其接受一个 `string` 和一个长度，并返回一个 `bool` 值表示该 `string` 的长度是否大于给定长度。但是，`find_if` 接受一元谓词，不能传递一个二元谓词，为了解决此问题，需要使用 **lambda**表达式。



#### 介绍 lambda

我们可以向一个算法传递任何类别的**可调用对象** 。对于一个对象或一个表达式，如果可以对其使用调用运算符`()` ，则称它为可调用对象。即，如果 `e` 是一个可调用表达式，则我们可以编写代码 `e(args)`，其中 `args` 是一个逗号分隔得一个或多个参数得列表。

**可调用对象有：**

- 函数
- 函数指针
- 重载了函数调用运算符的类
- lambda 表达式

<span style="border:2px solid Red; border-radius:5px;">C++11</span> 一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 lambda 具有返回类型、参数列表和函数体。但与函数不同，lambda 可能定义在函数内部。

lambda 表达式形式

```cpp
[capture list] (parameter list) -> return type { function body }
```

**capture list : ** 捕获列表是一个 lambda 所在函数中定义的局部变量

return type、parameter list 和 function body 与普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda 必须使用位置返回。

示例

```cpp
// 可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体
auto f = [] { return 42; };   // 定义一个可调用对象 f
cout << f() << endl;	// 调用，打印42
```

在 lambda 中忽略括号和参数列表等价于指定一个空参数列表。如果忽略返回类型，lambda 根据函数体中的代码推断出返回类型。如果函数体只要一个 `return` 语句，则返回类型从返回的表达式的类型推断而来。否则返回类型为 `void`。

> 如果 lambda d的函数体包含任何单一 `return` 语句之外的内容，且未指定返回类型，则返回 `void` 。



















