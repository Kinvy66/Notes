# Linux基础



本笔记转自[教程](https://www.bilibili.com/video/BV13U4y1p7kB)

## 1.  Linux命令



### 1.1 重定向操作

```shell
echo  helloworld	#在终端输出helloworld
echo helloworld > tmp	#将helloworld写入到temp文件中，会覆盖文件中原有的内容
echo helloworld >> tmp  #以追加的方式添加内容
```



### 1.2  压缩和解压命令 tar

1. **压缩**

   tar只能打包文件，不能够压缩文件。压缩工具：`gzip` `bzip2` ,但是不能打包压缩文件，每个文件都会生成一个单独的压缩包，并且压缩之后不会保留原文件

   > 如果使用 `tar` 完成文件压缩，涉及的的参数如下，在使用过程中没有先后顺序
   
   * `c`: 创建压缩文件
   * `z`: 使用`gzip` 的方式进行文件压缩
   * `j`: 使用`bzip2` 的方式进行文件压缩
   * `v`: 压缩过程中显示压缩信息，可以省略不写
   * `f`: 指定压缩包的名字
   
   > 一般认为 `.tgz` 文件等同于 `.tar.gz` 文件，因此它们的压缩方式是相同的
   
   ```shell
   #语法
   $ tar [参数] [生成的压缩包的名字] [要压缩的文件（文件或目录）]
   
   #备注: 关于生成的压缩包的名字，建议使用标准后缀，方便识别
   #	  -压缩使用gzip方式， 标准后缀格式为： .tar.gz
   #	  -压缩使用bzip2方式，标准后缀格式为： .tar.bz2
   ```
   
   > 举例： 使用 `gzip` 的方式进行文件压缩
   
   ```shell
   $ tar czvf all.tar.gz tmp.txt  temp/  #使用gzip压缩文件
   $ tar cjvf all.tar.bz2 tmp.txt  temp/  #使用把bzip2压缩文件
   
   ```
   
   



2. **解压**

   > 如果使用`tar` 进行文件的解压缩，设计的参数如下，在使用过程中参数没有先后顺序

   * `x`: 释放压缩文件内容
   * `z`: 使用 `gzip` 的方式进行文件解压缩，压缩包后缀为`.tar.gz`
   * `j`: 使用`bzip2` 的方式进行文件解压缩，压缩包后缀为`.tar.bz2`

   * `v`: 解压缩过程中显示解压缩信息
   * `f`: 指定压缩包的名字

   > 使用以上参数是将压缩包解压到当前目录，如果需要解压到指定目录，需要指定参数 `-c`, 一般认为 `.tgz` 文件等同于 `.tar.gz` 文件，解压缩方式是相同的，解压缩的语法格式如下：

   ```shell
   #语法1： 解压到当前目录中
   $ tar [参数] [压缩包名]
   
   #语法2： 解压到指定目录中
   $ tar [参数] [压缩包名] -C [解压目录]
   ```

   > 举例：使用`gzip` 的方式进行文件压缩

   ```shell
   # 将 all.tar.gz 压缩包解压缩到 temp 目录中
   $ tar zxvf all.tar.gz -C temp
   
   ```
   
   > 举例：使用bzip2的方式进行文件解压缩
   
   ```shell
   # 将 part.tar.bz2 中的文件加压缩到 temp 目录中
   $ tar jxvf part.tar.bz2 -C temp
   
   ```



### 1.3 zip

> zip格式的压缩包在Linux中也是常见的，在某些版本中需要安装才能使用

Ubuntu中安装zip

```shell
$ sudo apt install zip		#压缩
$ sudo apt install unzip	#解压缩
```



1. **压缩（.zip）**

   > 使用 `zip` 压缩目录需要注意一点，必须添加参数 `-r` ，这样才能将子目录中的文件一并压缩，如果要压缩的文件中没有哦目录，该参数可以不写
   >
   > 另外使用 `zip` 压缩文件，会自动生产文件后缀`.zip` ，因此就不需要额外指定了

   ```shell
   #语法：
   $ zip [-r] [压缩包名] [要压缩的文件]
   ```

   > 举例

   ```shell
   # 压缩目录 get 和文件 onepiece.txt robin.txt 得到压缩包 all.zip(不需要指定后缀, 自动添加)
   $ zip all onepiece.txt robin.txt get/ -r
   ```

   

2. **解压缩（.zip）**

   > 对应 zip 格式的文件解压缩，必须要使用 unzip 命令，和压缩的时候使用的命令是不一样的。如果压缩包中的文件要解压到指定目录需要指定参数 -d, 默认是解压缩到当前目录中。

   ```shell
   # 语法1: 解压到当前目录中 
   $ unzip 压缩包名
   
   # 语法: 解压到指定目录, 需要添加参数 -d
   $ unzip 压缩包名 -d 解压目录
   
   ```

   > 举例

   ```shell
   
   # 将 all.zip 解压缩到 temp 目录中
   $ unzip all.zip -d temp/
   ```



### 1.4 rar

> `rar` 这种压缩格式在 Linux 中并不常用，这是 Windows 常用的压缩格式，如果想要在 Linux 压缩和解压这种格式的文件需要额外安装对应的工具，不同版本的 Linux 安装方式也是不同的。

Ubuntu安装rar

```shell
sudo apt install rar
```



1. **压缩（.rar）**

   > 使用 `rar` 压缩过程中的注意事项和 `zip` 是一样的，`如果压缩的是目录, 需要指定参 -r`, 如果只压缩文件就不需要添加了。压缩过程中需要使用参数` a (archive)`, 压缩归档的意思。
   >
   > `rar` 工具在生成压缩包的时候也会自动添加后缀，名字为`.rar`, 因此我们只需要指定压缩包的名字

   ```shell
   # 文件压缩, 需要使用参数 a, 压缩包名会自动添加后缀 .rar
   # 如果压缩了目录, 需要加参数 -r
   # 语法: 
   $ rar a 压缩包名 要压缩的文件 [-r]
   
   # 压缩文件 onepiece.txt, robin.txt 和目录 get/ 到要是文件 all.rar 中
   $ rar a all onepiece.txt get/ robin.txt -r 
   ```



2. **解压缩（.rar）**

   >解压缩`.rar `格式的文件的时候，可以使用`rar` 也可以使用 `unrar`, 操作方式是一样的，需要添加参数 `x`, 默认是将压缩包内容释放到当前目录中，如果要释放到指定目录直接指定解压目录名即可，不需要使用任何参数。

   ```shell
   # 解压缩: 需要参数 x
   # 语法: 解压缩到当前目录中
   $ rar/unrar x 压缩包名字
   
   # 语法: 解压缩到指定目录中
   rar/unrar x 压缩包名字 解压目录
   
   ```

   > 举例

   ```shell
   # 将 all.rar 中的文件解压缩到 temp 目录中
   $ rar x all.rar temp/ 
   ```

   



### 1.5  xz

> `.xz` 格式的文件压缩和解压缩都相对比较麻烦，通过一个命令是完不成对应的操作的，需要通过两步操作才行。并且操作过程中需要使用 `tar` 工具进行打包，压缩使用的则是 `xz` 工具。



1. **压缩（.tar.xz）**

   >创建文件的步骤如下，首先 将需要压缩的文件打包 `tar cvf xxx.tar files`, 然后再对打包文件进行压缩 `xz -z xxx.tar`, 这样我们就可以得到一个打包之后的压缩文件了。
   >
   >使用 `xz` 工具压缩文件的时候需要添加参数 `-z`
   
   ```shell
   # 语法:
   # 第一步
   $ tar cvf xxx.tar 要压缩的文件
   # 第二步, 最终得到一个xxx.tar.xz 格式的压缩文件
   $ xz -z xxx.tar
   
   ```
   
   > 举例
   
   ```shell
   # 将文件 onepiece.txt, robin.txt 和目录 get 打包到 all.tar 中
   $ tar cvf all.tar onepiece.txt robin.txt get/
   
   ```



2. **解压缩（.tar.xz）**

   >解压缩的步骤和压缩的步骤相反，需要先解压缩，然后将文件包中的文件释放出来。
   >
   >使用 `xz`工具解压需要使用参数 `-d`。

   ```shell
   # 语法:
   # 第一步： 压缩包解压缩, 得到 xxx.tar
   $ xz -d xxx.tar.xz
   # 第二步: 将 xxx.tar 中的文件释放到当前目录
   $ tar xvf xxx.tar 			
   
   ```

   ```shell
   # 将 all.tar.xz 解压缩, 得到 all.tar
   $ xz -d all.tar.xz 
   
   ```



## 2. vim的使用

### 2.1  vim的模式

在vim中一共有三种模式，分别是 `命令模式` ，`末行模式` ，`编辑模式` ，当我们打开vim之后默认进入的是命令模式

* 命令模式：在该模式下我们可以进行`查看文件内容`，`修改文件` ，`关键的搜索`等操作
* 编辑模式：在该模式下主要对文件内容进行修改和内容添加
* 末行模式：在该模式下可以进行 `执行Linux命令` ，`保存文件` ，`进行行跳转`，`窗口分屏` 等操作



### 2.2 命令模式下的操作

* 命令

  ```shell
  ZZ   		#保存退出
  gg=G		#代码格式化	
  # 标准的移动光标的方法: 使用 h, j, k, l
  
                                          光标上移   
                                             ↑
                                             |
                       光标左移 <-- h    j    k    l --> 光标右移
                                         |
                                         ↓
                                      光标下移   
  ```



* 其他光标跳转命令

  |  快捷键  |        功能        |                      备注                       |
  | :------: | :----------------: | :---------------------------------------------: |
  |   `0`    |   光标移动到行首   |                      数字0                      |
  |   `$`    |  光标移动到行尾部  |                   `shift`+`4`                   |
  |   `gg`   |  光标移动到文件头  |                  第一行的开始                   |
  |   `G`    | 光标移动到文件尾部 |                 最后一行的开始                  |
  |   `nG`   |       行跳转       |             `n` 代表要跳转到哪一行              |
  | `n+回车` |    相对跳转n行     | 从光标所在当前行往下跳 n 行，n 对应的是一个整数 |

  ​                            

* 删除命令

  |  快捷键   |        功能        |                             备注                             |
  | :-------: | :----------------: | :----------------------------------------------------------: |
  | `x(小写)` | 删除光标后边的字符 |              vim中的光标比较宽会盖住后边的字符               |
  | `X(大写)` | 删除光标前边的字符 |                              无                              |
  |   `dw`    |      删除单词      | 要先把光标移动到单词的第一个字母上再删除, 否则单词只能被删除一部分 |
  |   `d0`    | 删除光标前的字符串 |           从字符串开头到光标当前位置的字符串被删除           |
  |  `d$(D)`  | 删除光标后的字符串 |   从光标当前位置到字符串尾部的字符串被删除，使用 `D` 也行    |
  |   `dd`    |   删除光标所在行   |                              无                              |
  |   `ndd`   |      删除n行       |                     从光标开始 删除`n`行                     |

  

* 撤销和反撤销

  |  快捷键  |  功能  |     备注     |
  | :------: | :----: | :----------: |
  |   `u`    |  撤销  | 等价`Ctrl+z` |
  | `Ctrl+r` | 反撤销 | 等价`Crtl+y` |



* 复制和粘贴

  | 快捷键 |          功能           |      备注       |
  | :----: | :---------------------: | :-------------: |
  |  `p`   | 粘贴到光标所在行的下边  |     `小写p`     |
  |  `P`   | 粘贴到光标所在行的上边  |     `大写P`     |
  |  `yy`  |    复制光标所在的行     |       无        |
  | `nyy`  | 从光标所在行向下复制n行 | n是要复制的行数 |



* 可视化模式

  `v`: 进入字符可视化模式，文本选择是以字符为单位的

  `V`: 进入行可视化模式，文本的选择是以行尾单位的

  `Ctrl+v`: 进入块可视化模式，可选择一个矩形内的文本

  

* 替换

  | 快捷键 |        功能        |      备注       |
  | :----: | :----------------: | :-------------: |
  |  `r`   | 替换光标的单个字符 |       无        |
  |  `R`   | 替换光标的多个字符 | 按`esc`结束替换 |

  

* 查找

  > 在 vim 的命令模式下一共有三种查找方式，首先需要在键盘上输入对应的字符，然后按回车键 vim 会进行关键字匹配，之后就可以通过 n 或者 N 进行关键字之间的切换了。

  

  | 搜索快捷键 | 关键字遍历 |      描述      | 备注 |
  | :--------: | :--------: | :------------: | ---- |
  |    `/`     |    `n`     | 从当前位置向下 |      |
  |            |    `N`     | 从当前位置向上 |      |
  |    `?`     |    `n`     | 从当前位置向上 |      |
  |            |    `N`     | 从当前位置向下 |      |
  |    `#`     |    `n`     | 从当前位置向上 |      |
  |            |    `N`     | 从当前位置向下 |      |

  

  

### 2.3 切换到编辑模式

> 从命令模式切换到编辑模式的操作



|   快捷键   |                            功能                            |
| :--------: | :--------------------------------------------------------: |
|    `i`     |                     从光标前边开始输入                     |
|    `a`     |                    从光标的后边开始输入                    |
|    `o`     |              在光标下边创建新行，在新行中输入              |
|    `s`     | 删除光标后边的字符（盖住的字符），从删除的字符位置开始输入 |
| `I(大写i)` |                    从当前行行首开始输入                    |
|    `A`     |                    从当前行行尾开始输入                    |
|    `O`     |               从光标上边创建新行，新行中输入               |
|    `S`     |                删除当前行，在当前行开始输入                |





### 2.4 末行模式下的操作



> 从命令模式切换到末行模式只需要在键盘上输入一个 :，同时这个符号也会出现在窗口的最下端，这时候我们就可以在最后一行输入我们执行的命令了。
>
> 从末行模式切换回命令模式有两种方式：
>
> 1. 按两次 Esc
> 2. 在末行模式下执行一个完整指令，执行完毕，自动回到命令模式



* 保存退出

  | 末行模式下的命令 |          功能          |
  | :--------------: | :--------------------: |
  |       `q`        | 退出，没保存会提示保存 |
  |       `q!`       |    强制退出(不保存)    |
  |       `w`        |      保存，不退出      |
  |       `wq`       |        保存退出        |
  |       `x`        |        保存退出        |

  

* 替换

  >替换对应的命令是 `s` 并且可以给其指定参数，默认情况下只替换相关行的第一个满足条件的关键字， 如果需要整行替换需要加参数 `/g`
|                末行模式下的替换命令                 |                            说明                            |
| :-------------------------------------------------: | :--------------------------------------------------------: |
|        `s/` 被替换的关键字 / 新的关键字 `/g`        |                   只对光标所在行进行替换                   |
| 行号 1, 行号 2`s/` 被替换的关键字 / 新的关键字 `/g` | `[行号1 , 行号2]` 是一个从小到大的范围，对这个范围进行替换 |
|       `%s/` 被替换的关键字 / 新的关键字 `/g`        |                  `%` 代表对所有行进行替换                  |



### 2.5 分屏

| 末行模式下的替换命令 |              说明              |                备注                |
| :------------------: | :----------------------------: | :--------------------------------: |
|         `sp`         |   水平分屏，多个窗口垂直排列   |  多个窗口中显示同一个文件里的内容  |
|        `vsp`         |   垂直分屏，多个窗口水平排列   |  多个窗口中显示同一个文件里的内容  |
|       `ctrl+p`       |    光标在打开的屏幕之间切换    | 快捷键操作(按住 ctrl 然后按两次 w) |
|        `qall`        |        同时退出多个屏幕        |                                    |
|       `wqall`        |      同时保存退出多个屏幕      |                                    |
|     `sp 文件名`      | 分屏的同时指定打开的文件的名字 |   在新窗口中显示指定的文件的内容   |
|     `vsp 文件名`     | 分屏的同时指定打开的文件的名字 |   在新窗口中显示指定的文件的内容   |

除了在命令模式下分屏，我们也可以在使用 vim 打开文件的时候直接分屏，下边是需要用到的参数:

`-o`: 水平分屏
`-O`: 垂直分屏

```shell
# 在vim打开文件的时候指定打开多个文件和分屏方式
# 水平分屏
$ vim -o 文件1, 文件2, 文件3 ...
# 垂直分屏
$ vim -O 文件1, 文件2, 文件3 ...
```





## 3. Makefile

### 3.1  规则



```makefile
#每条规则的语法格式
target1,taget2...:depend1,depend2,...
	command
	....
	
```

`命令(command)`: 当前这条规则的动作，一般情况下这个动作就是一个shell命令

​				动作可一个是多个， `每个命令前必须有一个tab缩进并且独占一行`

`依赖(depend)`: 规则所必需的依赖条件，在规则的命令中可以使用这些依赖

​				例如：生成可执行文件的目标文件(`*.o`)可以作为依赖使用

`目标(target)`: 规则中的目标，这个目标和规则中的命令是对应的



**示例：**

```makefile
# 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app
################# 例1 #################
app:a.c b.c c.c
	gcc a.c b.c c.c -o app

################# 例2 #################
# 有多个目标, 多个依赖, 多个命令
app,app1:a.c b.c c.c d.c
	gcc a.c b.c -o app
	gcc c.c d.c -o app1
	
################# 例3 #################	
# 规则之间的嵌套
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# a.o 是第一条规则中的依赖
a.o:a.c
	gcc -c a.c
# b.o 是第一条规则中的依赖
b.o:b.c
	gcc -c b.c
# c.o 是第一条规则中的依赖
c.o:c.c
	gcc -c c.c

```



### 3.2 工作原理



#### 3.2.1 规则的执行

在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作

**示例：**

```makefile
# makefile
# 规则之间的嵌套
# 规则1
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# 规则2
a.o:a.c
	gcc -c a.c
# 规则3
b.o:b.c
	gcc -c b.c
# 规则4
c.o:c.c
	gcc -c c.c

```



>在这个例子中，如果执行 make 命令就会根据这个 makefile 中的 4 条规则编译这三个源文件。在解析第一条规则的时候发现里边的三个依赖都是不存在的，因此规则对应的命令也就不能被执行。
>
>当依赖不存在的时候，make 就是查找其他的规则，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则 2， 规则 3， 规则 4 里的命令会相继被执行，当规则 1 中依赖全部被生成之后对应的命令也就被执行了，因此规则 1 的目标被生成，make 工作结束。



> 如果想要执行 makefile 中非第一条规则对应的命令，那么就不能直接 make, 需要将那条规则的目标也写到 make 的后边，比如只需要执行规则 3 中的命令，就需要: make b.o。



#### 3.2.2 文件的时间戳

make 命令执行的时候会根据文件的时间戳判定是否执行 Makefile文件中相关规则中的命令。



#### 3.2.3 自动推导

假设有以下文件：

```shell
$ tree
.
├── add.c
├── div.c
├── head.h
├── main.c
├── makefile
├── mult.c
└── sub.c

```

Makefile

```makefile
# 这是一个完整的 makefile 文件
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc

```



执行make

```shell
$ make
cc    -c -o add.o add.c
cc    -c -o div.o div.c
cc    -c -o main.o main.c
cc    -c -o mult.o mult.c
cc    -c -o sub.o sub.c
gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
```



> 我们可以发现上边的 makefile 文件中只有一条规则，依赖中所有的 .o 文件在本地项目目录中是不存在的，并且也没有其他的规则用来生成这些依赖文件，这时候 make 会使用内部默认的构造规则先将这些依赖文件生成出来，然后在执行规则中的命令，最后生成目标文件 calc。





### 3.3 变量

使用 Makefile 进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile 中的变量分为三种：`自定义变量`，`预定义变量`和`自动变量`。



#### 3.3.1 自定义变量

> 用 Makefile 进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。makefile 中的变量是没有类型的，直接创建变量然后给其赋值就可以了。

**示例1**

```makefile
# 错误, 只创建了变量名, 没有赋值
变量名 
# 正确, 创建一个变量名并且给其赋值
变量名=变量值
```



**示例2**:变量的定义和使用

```makefile
# 如果将变量的值取出?
$(变量的名字)

# 举例 add.o  div.o  main.o  mult.o  sub.o
# 定义变量并赋值
obj=add.o  div.o  main.o  mult.o  sub.o
# 取变量的值
$(obj)
```



**示例3：** 

```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
$(target):$(obj)
        gcc  $(obj) -o $(target)

```



#### 3.3.2  预定义变量

在 Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：

|  变量名  |             含义             |  默认值  |
| :------: | :--------------------------: | :------: |
|    AR    |  生成静态库库文件的程序名称  |    ar    |
|    AS    |       汇编编译器的名称       |    as    |
|    CC    |      C 语言编译器的名称      |    cc    |
|   CPP    |     C 语言预编译器的名称     | $(CC) -E |
|   CXX    |     C++ 语言编译器的名称     |   g++    |
|    FC    |   FORTRAN 语言编译器的名称   |   f77    |
|    RM    |      删除文件程序的名称      |  rm -f   |
| ARFLAGS  |  生成静态库库文件程序的选项  | 无默认值 |
| ASFLAGS  |   汇编语言编译器的编译选项   | 无默认值 |
|  CFLAGS  |    C 语言编译器的编译选项    | 无默认值 |
| CPPFLAGS |    C 语言预编译的编译选项    | 无默认值 |
| CXXFLAGS |   C++ 语言编译器的编译选项   | 无默认值 |
|  FFLAGS  | FORTRAN 语言编译器的编译选项 | 无默认值 |



```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量和预定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
CFLAGS=-O3 # 代码优化
$(target):$(obj)
        $(CC)  $(obj) -o $(target) $(CFLAGS)
```



#### 3.3.3  自动化变量

Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。Makefile 中的规则语句中经常会出现目标文件和依赖文件，`自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。`

下表中是一些常见的自动变量

| 变量 | 含义                                                         |
| :--: | :----------------------------------------------------------- |
|  $*  | 表示目标文件的名称，不包含目标文件的扩展名                   |
|  $+  | 表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件 |
|  $<  | 表示依赖项中第一个依赖文件的名称                             |
|  $?  | 依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开 |
|  $@  | 表示目标文件的名称，包含文件扩展名                           |
|  $^  | 依赖项中，所有不重复的依赖文件，这些文件之间以空格分开       |



**示例：**

```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
# 使用自动变量, 替换相关的内容
calc:add.o  div.o  main.o  mult.o  sub.o
	gcc $^ -o $@ 			# 自动变量只能在规则的命令中使用
```





### 3.4 模式匹配

**示例：**

```makefile
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
# 语法格式重复的规则, 将 .c -> .o, 使用的命令都是一样的 gcc *.c -c
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c
```



**改写：**

```makefile
# 模式匹配 -> 通过一个公式, 代表若干个满足条件的规则
# 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名
%.o:%.c
	gcc $< -c
	
```



![image-20200418143747981](https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/20210702190648.png)





### 3.5 函数

makefile 中有很多函数并且`所有的函数都是有返回值的。`makefile 中函数的格式和 C/C++ 中函数也不同，其写法是这样的： `$(函数名 参数1, 参数2, 参数3, ...)`，主要目的是让我们能够快速方便的得到函数的返回值。

这里为大家介绍两个 makefile 中使用频率比较高的函数：`wildcard` 和 `patsubst`。



#### 3.5.1  wildcard

这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：

```makefile
# 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔
$(wildcard PATTERN...)
	参数:	指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c
```

参数功能：

​		PATTERN 指的是某个或多个目录下的对应的某种类型的文件，比如当前`目录下的.c` 文件可以写成 `*.c`

​		可以指定多个目录，每个路径之间使用空格间隔
返回值：

​		得到的若干个文件的文件列表， 文件名之间使用空格间隔
​		示例：`$(wildcard *.c ./sub/*.c)`
​				返回值格式: a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c

函数使用举例:

```makefile
# 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件
src = $(wildcard /home/robin/a/*.c /home/robin/b/*.c *.c)  # *.c == ./*.c
# 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔
/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c

```





#### 3.5.2  patsubst

这个函数的功能是按照指定的模式替换指定的文件名的后缀，函数原型如下:

```makefile
# 有三个参数, 参数之间使用 逗号间隔
$(patsubst <pattern>,<replacement>,<text>)
```

参数功能:
	pattern: 这是一个模式字符串，需要指定出要被替换的文件名中的后缀是什么
			文件名和路径不需要关心，因此使用 % 表示即可 [通配符是 %]
			在通配符后边指定出要被替换的后缀，比如: %.c, 意味着 .c 的后缀要被替换掉
replacement: 这是一个模式字符串，指定参数 pattern 中的后缀最终要被替换为什么
			还是使用 % 来表示参数 pattern 中文件的路径和名字
			在通配符 % 后边指定出新的后缀名，比如: %.o 这表示原来的后缀被替换为 .o
text: 该参数中存储这要被替换的原始数据
返回值:
			函数返回被替换过后的字符串。
函数使用举例:

```makefile
src = a.cpp b.cpp c.cpp e.cpp
# 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o
obj = $(patsubst %.cpp, %.o, $(src)) 
# obj 的值为: a.o b.o c.o e.o
```





### 3.6  实例

**文件：**

```shell
# 项目目录结构
.
├── add.c
├── div.c
├── head.h
├── main.c
├── mult.c
└── sub.c
# 需要编写makefile对该项目进行自动化编译
```



**Version1：**

```makefile
calc:add.c  div.c  main.c  mult.c  sub.c
        gcc add.c  div.c  main.c  mult.c  sub.c -o calc

```



**version2：**

```makefile
# 默认所有的依赖都不存在, 需要使用其他规则生成这些依赖
# 因为 add.o 被更新, 需要使用最新的依赖, 生成最新的目标
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc

# 如果修改了add.c, add.o 被重新生成
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c

```



**version3：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c
```



**version4：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
# % 匹配的内容是不能被替换的, 需要替换的是第一个参数中的后缀, 替换为第二个参数中指定的后缀
# obj=$(patsubst %.cpp, %.o, $(src)) 将src中的关键字 .cpp 替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c
```



**version5：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc
# obj 的值 xxx.o xxx.o xxx.o xx.o
$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c

# 添加规则, 删除生成文件 *.o 可执行程序
# 这个规则比较特殊, clean根本不会生成, 这是一个伪目标
clean:
        rm $(obj) $(target)
```



正常情况下这个版本的 makefile 是可以正常工作的，但是我们如果在这个项目目录中添加一个叫做 `clean` 的文件（和规则中的目标名称相同），再进行 `make clean` 发现这个规则就不能正常工作了。

```makefile
# 在项目目录中添加一个叫 clean的文件, 然后在 make clean 这个规则中的命令就不工作了
$ ls
add.c  calc   div.c  head.h  main.o    mult.c  sub.c
add.o  div.o  main.c  makefile  mult.o  sub.o  clean  ---> 新添加的

# 使用 makefile 中的规则删除生成的目标文件和可执行程序
$ make clean
make: 'clean' is up to date. 

# 查看目录, 发现相关文件并没有被删除, make clean 失败了
$ ls
add.c  calc   div.c  head.h  main.o    mult.c  sub.c
add.o  clean  div.o  main.c  makefile  mult.o  sub.o
```



**最终版：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c

# 添加规则, 删除生成文件 *.o 可执行程序
# 声明clean为伪文件
.PHONY:clean
clean:
        # shell命令前的 - 表示强制这个指令执行, 如果执行失败也不会终止
        -rm $(obj) $(target) 
        echo "hello, 我是测试字符串"

```







### 3.7 case

```shell
# 目录结构
.
├── include
│   └── head.h	==> 头文件, 声明了加减乘除四个函数
├── main.c		==> 测试程序, 调用了head.h中的函数
└── src
    ├── add.c	==> 加法运算
    ├── div.c	==> 除法运算
    ├── mult.c  ==> 乘法运算
    └── sub.c   ==> 减法运算
```



根据上边的项目目录结构编写的 makefile 文件如下:

```makefile
# 最终的目标名 app
target = app
# 搜索当前项目目录下的源文件
src=$(wildcard *.c ./src/*.c)
# 将文件的后缀替换掉 .c -> .o
obj=$(patsubst %.c, %.o, $(src))
# 头文件目录
include=./include

# 第一条规则
# 依赖中都是 xx.o yy.o zz.o
# gcc命令执行的是链接操作
$(target):$(obj)
        gcc $^ -o $@

# 模式匹配规则
# 执行汇编操作, 前两步: 预处理, 编译是自动完成
%.o:%.c
        gcc $< -c -I $(include) -o $@

# 添加一个清除文件的规则
.PHONY:clean

clean:
        -rm $(obj) $(target) -f
```





## 4. GDB



### 4.1 调试准备

要调试一个程序，在编译是必须要打开调试选项（`-g`）,另外还有一些可选项，比如：关掉编译器的优化（`-O0`）

`-g` 选项的作用是在可执行文件中加入源代码信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。这样编译的文件会更大些。

```shell
# -g 将调试信息写入到可执行程序中
$ gcc -g args.c -o app

# 编译不添加 -g 参数
$ gcc args.c -o app1  

```





### 4.2 启动和退出gdb

#### 4.2.1 启动gdb

```shell
# 在终端中执行如下命令
# gdb程序启动了, 但是可执行程序并没有执行
$ gdb 可执行程序的名字

# 使用举例：
$ gdb app
(gdb) 		# gdb等待输入调试的相关命令
```



#### 4.2.2 命令行传参

> 有些程序在启动的时候需要传递命令行参数，如果要调试这类程序，这些命令行参数必须要在应用程序启动之前通过调试程序的 gdb 进程传递进去。下面是一段带命令行参数的程序：
>



```c
// args.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define NUM 10

// argc, argv 是命令行参数
// 启动应用程序的时候
int main(int argc, char* argv[])
{
    printf("参数个数: %d\n", argc);
    for(int i=0; i<argc; ++i)
    {
        printf("%d\n", NUM);
        printf("参数 %d: %s\n", i, argv[i]);
    }
    return 0;
}
```

执行调试：

```shell
#1.编译出带调试信息的可执行程序
$ gcc args.c -o app -g
#2.启动gdb进程，指定需要gdb调试的应用程序名称
$ gbd app
#3.设置命令行参数
(gdb) set args  参数1，参数2，...		#设置参数
(gdb) show args  			#查看设置的命令行参数

```



#### 4.2.3  gdb中启动程序

> 在 gdb 中启动要调试的应用程序有两种方式，一种是使用 run 命令，另一种是使用 start 命令启动。在整个 gdb 调试过程中，启动应用程序的命令只能使用一次。
>

`run` ：可以缩写为`r` ,如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完

`start`：启动程序，最终会阻塞在main函数的第一行，等待输入后续其他gdb命令

如果想让程序 `start` 之后继续运行，或者在断点处继续运行，可以使用 `continue` 命令，可以简写为 `c`



#### 4.2.4 退出gdb

退出 gdb 调试，就是终止 gdb 进程，需要使用 `quit` 命令，可以缩写为 `q`





### 4.3 查看代码

查看代码的命令叫做 `list` 可以缩写为 `l`, 通过这个命令我们可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。



#### 4.3.1 查看代码

>一个项目中一般是有很多源文件的，默认情况下通过 list 查看到代码信息位于程序入口函数 main 对应的的那个文件中。因此如果不进行文件切换 main 函数所在的文件就是当前文件，如果进行了文件切换，切换到哪个文件哪个文件就是当前文件。查看文件内容的方式如下：
>

```shell
# 使用 list 和使用 l 都可以
# 从第一行开始显示
(gdb) list 

# 列值这行号对应的上下文代码, 默认情况下只显示10行内容
(gdb) list 行号

# 显示这个函数的上下文内容, 默认显示10行
(gdb) list 函数名
```

通过 list 去查看文件代码，默认只显示 10 行，如果还想继续查看后边的内容，可以继续执行 list 命令，也可以直接回车（再次执行上一次执行的那个 gdb 命令）。

#### 4.3.2  切换文件

> 在查看文件内容的时候，很多情况下需要进行文件切换，我们只需要在 list 命令后边将要查看的文件名指定出来就可以了，切换命令执行完毕之后，这个文件就变成了当前文件。文件切换方式如下：
>

```shell
# 切换到指定的文件，并列出这行号对应的上下文代码, 默认情况下只显示10行内容
(gdb) l 文件名:行号

# 切换到指定的文件，并显示这个函数的上下文内容, 默认显示10行
(gdb) l 文件名:函数名
```





#### 4.3.3 设置显示的行数

> 默认通过 list 只能一次查看 10 行代码，如果想显示更多，可以通过 `set listsize` 设置，同样如果想查看当前显示的行数可以通过 `show listsize` 查看，这里的 `listsize` 可以简写为 `list`。
>
> 具体语法格式如下:

```shell
# 以下两个命令中的 listsize 都可以写成 list
(gdb) set listsize 行数

# 查看当前list一次显示的行数
(gdb) show listsize
```



### 4.4 断点操作

设置断点的命令叫做 `break` 可以缩写为 `b`



#### 4.4.1 设置断点

> 断点的设置有两种方式一种是常规断点，程序只要运行到这个位置就会被阻塞，还有一种叫条件断点，只有指定的条件被满足了程序才会在断点处阻塞。
>
> 调试程序的断点可以设置到某个具体的行，也可以设置到某个函数上，具体的设置方式如下：
>

设置断点到当前文件

```shell
# 在当前文件的某一行上设置断点
# break == b
(gdb) b 行号
(gdb) b 函数名		# 停止在函数的第一行
```

设置普通断点到某个非当前文件上

```shell
# 在非当前文件的某一行上设置断点
(gdb) b 文件名:行号
(gdb) b 文件名:函数名		# 停止在函数的第一行
```

设置条件断点

```shell
# 必须要满足某个条件, 程序才会停在这个断点的位置上
# 通常情况下, 在循环中条件断点用的比较多
(gdb) b 行数 if 变量名==某个值
```



#### 4.4.2  查看断点

> 断点设置完毕之后，可以通过 info break 命令查看设置的断点信息，其中 info 可以缩写为 i
>

```shell
# info == i
# 查看设置的断点信息
(gdb) i b   #info break

# 举例
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400cb5 in main() at test.cpp:12
2       breakpoint     keep y   0x0000000000400cbd in main() at test.cpp:13
3       breakpoint     keep y   0x0000000000400cec in main() at test.cpp:18
4       breakpoint     keep y   0x00000000004009a5 in insertionSort(int*, int) 
                                                   at insert.cpp:8
5       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16
6       breakpoint     keep y   0x00000000004009e5 in insertionSort(int*, int) 
                                                   at insert.cpp:16
```

在显示的断点信息中有一些属性需要在其他操作中被使用，下面介绍一下:

`Num`: 断点的编号，删除断点或者设置断点状态的时候都需要使用
`Enb`: 当前断点的状态，y 表示断点可用，n 表示断点不可用
`What`: 描述断点被设置在了哪个文件的哪一行或者哪个函数上



#### 4.4.3 删除断点

> 如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 delete 断点编号 , 这个 delete 可以简写为 del 也可以再简写为 d。
>
> 删除断点的方式有两种: 删除(一个或者多个)指定断点或者删除一个连续的断点区间，具体操作如下：
>

```shell
# delete == del == d
# 需要 info b 查看断点的信息, 第一列就是编号
(gdb) d 断点的编号1 [断点编号2 ...]
# 举例: 
(gdb) d 1          # 删除第1个断点
(gdb) d 2 4 6      # 删除第2,4,6个断点

# 删除一个范围, 断点编号 num1 - numN 是一个连续区间
(gdb) d num1-numN
# 举例, 删除第1到第5个断点
(gdb) d 1-5
```



#### 4.4.4 设置断点状态

> 如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为 `disable 断点编号`，当需要的时候再将其设置回可用状态，设置命令为 `enable 断点编号`。
>

设置断点无效

```shell
# 让断点失效之后, gdb调试过程中程序是不会停在这个位置的
# disable == dis
# 设置某一个或者某几个断点无效
(gdb) dis 断点1的编号 [断点2的编号 ...]

# 设置某个区间断点无效
(gdb) dis 断点1编号-断点n编号
```

让无效的断点生效

```shell
# enable == ena
# 设置某一个或者某几个断点有效
(gdb) ena 断点1的编号 [断点2的编号 ...]

# 设置某个区间断点有效
(gdb) ena 断点1编号-断点n编号
```



### 4.5 调试命令

### 4.5.1 继续运行gdb

> 如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用 `continue` 命令。程序会继续运行，直到遇到下一个有效的断点。`continue` 可以缩写为 `c`。
>

```shell
# continue == c
(gdb) continue
```

#### 4.5.2  手动打印信息

> 当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。
>



1. **打印变量值**

   在 gdb 调试的时候如果需要打印变量的值， 使用的命令是 `print`, 可缩写为 `p`。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：

   | 格式字符（/fmt) |                说明                |
   | :-------------: | :--------------------------------: |
   |      `/x`       |     以十六进制的形式打印出整数     |
   |      `/d`       |  以有符号、十进制的形式打印出整数  |
   |      `/u`       |  以无符号、十进制的形式打印出整数  |
   |      `/o`       |      以八进制的形式打印出整数      |
   |      `/t`       |      以二进制的形式打印出整数      |
   |      `/f`       | 以浮点数的形式打印变量或表达式的值 |
   |      `/c`       |   以字符形式打印变量或表达式的值   |

   print命令的语法格式如下：

   ```shell
   # print == p
   (gdb) p 变量名
   
   # 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表
   (gdb) p/fmt 变量名
   ```



2. **打印变量类型**

   如果在调试过程中需要查看某个变量的类型，可以使用命令 `ptype`, 语法格式如下:

   ```shell
   # 语法格式
   (gdb) ptype 变量名
   ```

   



#### 4.5.3 自动打印信息

1. **设置变量名自动显示**

   和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 display 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动帮我们打印出来，而 print 命令则不会。因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式，常用的语法格式如下 2 种：

   ```shell
   # 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示)
   (gdb) display 变量名
   
   # 以指定的整形格式打印变量的值, 关于 fmt 的取值, 请参考 print 命令
   (gdb) display/fmt 变量名
   ```



2. **查看自动显示列表**

   对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为自动显示列表）中。通过执行 `info dispaly` 命令，可以打印出这张表：

   ```shell
   # info == i
   (gdb) info display
   Auto-display expressions now in effect:
   Num Enb Expression
   1:   y  i
   2:   y  array[i]
   3:   y  /x array[i]
   ```

   在展示出的信息中，每个列的含义如下:

   `Num` : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号
   `Enb` : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。
   `Expression` ：被自动打印值的变量或表达式的名字。

3. **取消自动显示**

   对于不需要再打印值的变量或表达式，可以将其删除或者禁用。

   删除自动显示列表中的变量或表达式

   ```shell
   # 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
   (gdb) undisplay num [num1 ...]
   # num1 - numN 表示一个范围
   (gdb) undisplay num1-numN
   
   (gdb) delete display num [num1 ...]
   (gdb) delete display num1-numN
   ```

   如果不想删除自动显示的变量，也可以禁用自动显示列表中处于激活状态下的变量或表达式

   ```shell
   # 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
   (gdb) disable display num [num1 ...]
   # num1 - numN 表示一个范围
   (gdb) disable display num1-numN
   ```

   当需要启用自动显示列表中被禁用的变量或表达式时，可以使用下边的命令

   ```shell
   # 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
   (gdb) enable  display num [num1 ...]
   # num1 - numN 表示一个范围
   (gdb) disable display num1-numN
   ```



#### 4.5.4  单步调试

> 当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试:



1. **step**

   `step` 命令可以缩写为 `s`, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。

   ```shell
   # 从当前代码行位置, 一次调试当前行下的每一行代码
   # step == s
   # 如果这一行是函数调用, 执行这个命令, 就可以进入到函数体的内部
   (gdb) step
   ```

2. **finish**

   如果通过 s 单步调试进入到函数内部，想要跳出这个函数体， 可以执行 `finish` 命令。==如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出==。

   ```shell
   # 如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体
   (gdb) finish
   ```



3. **next**

   `next` 命令和 step 命令功能是相似的，只是在使用 next 调试程序的时候不会进入到函数体内部，`next` 可以缩写为 `n`

   ```shell
   # next == n
   # 如果这一行是函数调用, 执行这个命令, 不会进入到函数体的内部
   (gdb) next
   ```

   

4. **until**通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：

   * 要跳出的循环体内部不能有有效的断点
   * 必须要在循环体的开始 / 结束行执行该命令

   ```shell
   (gdb) until
   ```

   

#### 4.5.5 设置变量值

> 在调试程序的时候，我们需要在某个变量等于某个特殊值的时候查看程序的运行状态，但是通过程序运行让变量等于这个值又非常困难，这种情况下就可以在 gdb 中直接对这个变量进行值的设置，或者是在单步调试的时候通过设置循环因子的值直接跳出某个循环，值设置的命令格式为: `set var 变量名=值`
>

```shell
# 可以在循环中使用, 直接设置循环因子的值
# 假设某个变量的值在程序中==90的概率是5%, 这时候可以直接通过命令将这个变量值设置为90
(gdb) set var 变量名=值
```

