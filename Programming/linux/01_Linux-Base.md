# Linux基础



[教程](https://www.bilibili.com/video/BV13U4y1p7kB)

## 1.  Linux命令



### 1.1 重定向操作

```shell
echo  helloworld	#在终端输出helloworld
echo helloworld > tmp	#将helloworld写入到temp文件中，会覆盖文件中原有的内容
echo helloworld >> tmp  #以追加的方式添加内容
```



### 1.2  压缩和解压命令 tar

1. **压缩**

   tar只能打包文件，不能够压缩文件。压缩工具：`gzip` `bzip2` ,但是不能打包压缩文件，每个文件都会生成一个单独的压缩包，并且压缩之后不会保留原文件

   > 如果使用 `tar` 完成文件压缩，涉及的的参数如下，在使用过程中没有先后顺序
   
   * `c`: 创建压缩文件
   * `z`: 使用`gzip` 的方式进行文件压缩
   * `j`: 使用`bzip2` 的方式进行文件压缩
   * `v`: 压缩过程中显示压缩信息，可以省略不写
   * `f`: 指定压缩包的名字
   
   > 一般认为 `.tgz` 文件等同于 `.tar.gz` 文件，因此它们的压缩方式是相同的
   
   ```shell
   #语法
   $ tar [参数] [生成的压缩包的名字] [要压缩的文件（文件或目录）]
   
   #备注: 关于生成的压缩包的名字，建议使用标准后缀，方便识别
   #	  -压缩使用gzip方式， 标准后缀格式为： .tar.gz
   #	  -压缩使用bzip2方式，标准后缀格式为： .tar.bz2
   ```
   
   > 举例： 使用 `gzip` 的方式进行文件压缩
   
   ```shell
   $ tar czvf all.tar.gz tmp.txt  temp/  #使用gzip压缩文件
   $ tar cjvf all.tar.bz2 tmp.txt  temp/  #使用把bzip2压缩文件
   
   ```
   
   



2. **解压**

   > 如果使用`tar` 进行文件的解压缩，设计的参数如下，在使用过程中参数没有先后顺序

   * `x`: 释放压缩文件内容
   * `z`: 使用 `gzip` 的方式进行文件解压缩，压缩包后缀为`.tar.gz`
   * `j`: 使用`bzip2` 的方式进行文件解压缩，压缩包后缀为`.tar.bz2`

   * `v`: 解压缩过程中显示解压缩信息
   * `f`: 指定压缩包的名字

   > 使用以上参数是将压缩包解压到当前目录，如果需要解压到指定目录，需要指定参数 `-c`, 一般认为 `.tgz` 文件等同于 `.tar.gz` 文件，解压缩方式是相同的，解压缩的语法格式如下：

   ```shell
   #语法1： 解压到当前目录中
   $ tar [参数] [压缩包名]
   
   #语法2： 解压到指定目录中
   $ tar [参数] [压缩包名] -C [解压目录]
   ```

   > 举例：使用`gzip` 的方式进行文件压缩

   ```shell
   # 将 all.tar.gz 压缩包解压缩到 temp 目录中
   $ tar zxvf all.tar.gz -C temp
   
   ```
   
   > 举例：使用bzip2的方式进行文件解压缩
   
   ```shell
   # 将 part.tar.bz2 中的文件加压缩到 temp 目录中
   $ tar jxvf part.tar.bz2 -C temp
   
   ```



### 1.3 zip

> zip格式的压缩包在Linux中也是常见的，在某些版本中需要安装才能使用

Ubuntu中安装zip

```shell
$ sudo apt install zip		#压缩
$ sudo apt install unzip	#解压缩
```



1. **压缩（.zip）**

   > 使用 `zip` 压缩目录需要注意一点，必须添加参数 `-r` ，这样才能将子目录中的文件一并压缩，如果要压缩的文件中没有哦目录，该参数可以不写
   >
   > 另外使用 `zip` 压缩文件，会自动生产文件后缀`.zip` ，因此就不需要额外指定了

   ```shell
   #语法：
   $ zip [-r] [压缩包名] [要压缩的文件]
   ```

   > 举例

   ```shell
   # 压缩目录 get 和文件 onepiece.txt robin.txt 得到压缩包 all.zip(不需要指定后缀, 自动添加)
   $ zip all onepiece.txt robin.txt get/ -r
   ```

   

2. **解压缩（.zip）**

   > 对应 zip 格式的文件解压缩，必须要使用 unzip 命令，和压缩的时候使用的命令是不一样的。如果压缩包中的文件要解压到指定目录需要指定参数 -d, 默认是解压缩到当前目录中。

   ```shell
   # 语法1: 解压到当前目录中 
   $ unzip 压缩包名
   
   # 语法: 解压到指定目录, 需要添加参数 -d
   $ unzip 压缩包名 -d 解压目录
   
   ```

   > 举例

   ```shell
   
   # 将 all.zip 解压缩到 temp 目录中
   $ unzip all.zip -d temp/
   ```



### 1.4 rar

> `rar` 这种压缩格式在 Linux 中并不常用，这是 Windows 常用的压缩格式，如果想要在 Linux 压缩和解压这种格式的文件需要额外安装对应的工具，不同版本的 Linux 安装方式也是不同的。

Ubuntu安装rar

```shell
sudo apt install rar
```



1. **压缩（.rar）**

   > 使用 `rar` 压缩过程中的注意事项和 `zip` 是一样的，`如果压缩的是目录, 需要指定参 -r`, 如果只压缩文件就不需要添加了。压缩过程中需要使用参数` a (archive)`, 压缩归档的意思。
   >
   > `rar` 工具在生成压缩包的时候也会自动添加后缀，名字为`.rar`, 因此我们只需要指定压缩包的名字

   ```shell
   # 文件压缩, 需要使用参数 a, 压缩包名会自动添加后缀 .rar
   # 如果压缩了目录, 需要加参数 -r
   # 语法: 
   $ rar a 压缩包名 要压缩的文件 [-r]
   
   # 压缩文件 onepiece.txt, robin.txt 和目录 get/ 到要是文件 all.rar 中
   $ rar a all onepiece.txt get/ robin.txt -r 
   ```



2. **解压缩（.rar）**

   >解压缩`.rar `格式的文件的时候，可以使用`rar` 也可以使用 `unrar`, 操作方式是一样的，需要添加参数 `x`, 默认是将压缩包内容释放到当前目录中，如果要释放到指定目录直接指定解压目录名即可，不需要使用任何参数。

   ```shell
   # 解压缩: 需要参数 x
   # 语法: 解压缩到当前目录中
   $ rar/unrar x 压缩包名字
   
   # 语法: 解压缩到指定目录中
   rar/unrar x 压缩包名字 解压目录
   
   ```

   > 举例

   ```shell
   # 将 all.rar 中的文件解压缩到 temp 目录中
   $ rar x all.rar temp/ 
   ```

   



### 1.5  xz

> `.xz` 格式的文件压缩和解压缩都相对比较麻烦，通过一个命令是完不成对应的操作的，需要通过两步操作才行。并且操作过程中需要使用 `tar` 工具进行打包，压缩使用的则是 `xz` 工具。



1. **压缩（.tar.xz）**

   >创建文件的步骤如下，首先 将需要压缩的文件打包 `tar cvf xxx.tar files`, 然后再对打包文件进行压缩 `xz -z xxx.tar`, 这样我们就可以得到一个打包之后的压缩文件了。
   >
   >使用 `xz` 工具压缩文件的时候需要添加参数 `-z`
   
   ```shell
   # 语法:
   # 第一步
   $ tar cvf xxx.tar 要压缩的文件
   # 第二步, 最终得到一个xxx.tar.xz 格式的压缩文件
   $ xz -z xxx.tar
   
   ```
   
   > 举例
   
   ```shell
   # 将文件 onepiece.txt, robin.txt 和目录 get 打包到 all.tar 中
   $ tar cvf all.tar onepiece.txt robin.txt get/
   
   ```



2. **解压缩（.tar.xz）**

   >解压缩的步骤和压缩的步骤相反，需要先解压缩，然后将文件包中的文件释放出来。
   >
   >使用 `xz`工具解压需要使用参数 `-d`。

   ```shell
   # 语法:
   # 第一步： 压缩包解压缩, 得到 xxx.tar
   $ xz -d xxx.tar.xz
   # 第二步: 将 xxx.tar 中的文件释放到当前目录
   $ tar xvf xxx.tar 			
   
   ```

   ```shell
   # 将 all.tar.xz 解压缩, 得到 all.tar
   $ xz -d all.tar.xz 
   
   ```



## 2. vim的使用

### 2.1  vim的模式

在vim中一共有三种模式，分别是 `命令模式` ，`末行模式` ，`编辑模式` ，当我们打开vim之后默认进入的是命令模式

* 命令模式：在该模式下我们可以进行`查看文件内容`，`修改文件` ，`关键的搜索`等操作
* 编辑模式：在该模式下主要对文件内容进行修改和内容添加
* 末行模式：在该模式下可以进行 `执行Linux命令` ，`保存文件` ，`进行行跳转`，`窗口分屏` 等操作



### 2.2 命令模式下的操作

* 命令

  ```shell
  ZZ   		#保存退出
  gg=G		#代码格式化	
  # 标准的移动光标的方法: 使用 h, j, k, l
  
                                          光标上移   
                                             ↑
                                             |
                       光标左移 <-- h    j    k    l --> 光标右移
                                         |
                                         ↓
                                      光标下移   
  ```



* 其他光标跳转命令

  |  快捷键  |        功能        |                      备注                       |
  | :------: | :----------------: | :---------------------------------------------: |
  |   `0`    |   光标移动到行首   |                      数字0                      |
  |   `$`    |  光标移动到行尾部  |                   `shift`+`4`                   |
  |   `gg`   |  光标移动到文件头  |                  第一行的开始                   |
  |   `G`    | 光标移动到文件尾部 |                 最后一行的开始                  |
  |   `nG`   |       行跳转       |             `n` 代表要跳转到哪一行              |
  | `n+回车` |    相对跳转n行     | 从光标所在当前行往下跳 n 行，n 对应的是一个整数 |

  ​                            

* 删除命令

  |  快捷键   |        功能        |                             备注                             |
  | :-------: | :----------------: | :----------------------------------------------------------: |
  | `x(小写)` | 删除光标后边的字符 |              vim中的光标比较宽会盖住后边的字符               |
  | `X(大写)` | 删除光标前边的字符 |                              无                              |
  |   `dw`    |      删除单词      | 要先把光标移动到单词的第一个字母上再删除, 否则单词只能被删除一部分 |
  |   `d0`    | 删除光标前的字符串 |           从字符串开头到光标当前位置的字符串被删除           |
  |  `d$(D)`  | 删除光标后的字符串 |   从光标当前位置到字符串尾部的字符串被删除，使用 `D` 也行    |
  |   `dd`    |   删除光标所在行   |                              无                              |
  |   `ndd`   |      删除n行       |                     从光标开始 删除`n`行                     |

  

* 撤销和反撤销

  |  快捷键  |  功能  |     备注     |
  | :------: | :----: | :----------: |
  |   `u`    |  撤销  | 等价`Ctrl+z` |
  | `Ctrl+r` | 反撤销 | 等价`Crtl+y` |



* 复制和粘贴

  | 快捷键 |          功能           |      备注       |
  | :----: | :---------------------: | :-------------: |
  |  `p`   | 粘贴到光标所在行的下边  |     `小写p`     |
  |  `P`   | 粘贴到光标所在行的上边  |     `大写P`     |
  |  `yy`  |    复制光标所在的行     |       无        |
  | `nyy`  | 从光标所在行向下复制n行 | n是要复制的行数 |



* 可视化模式

  `v`: 进入字符可视化模式，文本选择是以字符为单位的

  `V`: 进入行可视化模式，文本的选择是以行尾单位的

  `Ctrl+v`: 进入块可视化模式，可选择一个矩形内的文本

  

* 替换

  | 快捷键 |        功能        |      备注       |
  | :----: | :----------------: | :-------------: |
  |  `r`   | 替换光标的单个字符 |       无        |
  |  `R`   | 替换光标的多个字符 | 按`esc`结束替换 |

  

* 查找

  > 在 vim 的命令模式下一共有三种查找方式，首先需要在键盘上输入对应的字符，然后按回车键 vim 会进行关键字匹配，之后就可以通过 n 或者 N 进行关键字之间的切换了。

  

  | 搜索快捷键 | 关键字遍历 |      描述      | 备注 |
  | :--------: | :--------: | :------------: | ---- |
  |    `/`     |    `n`     | 从当前位置向下 |      |
  |            |    `N`     | 从当前位置向上 |      |
  |    `?`     |    `n`     | 从当前位置向上 |      |
  |            |    `N`     | 从当前位置向下 |      |
  |    `#`     |    `n`     | 从当前位置向上 |      |
  |            |    `N`     | 从当前位置向下 |      |

  

  

### 2.3 切换到编辑模式

> 从命令模式切换到编辑模式的操作



|   快捷键   |                            功能                            |
| :--------: | :--------------------------------------------------------: |
|    `i`     |                     从光标前边开始输入                     |
|    `a`     |                    从光标的后边开始输入                    |
|    `o`     |              在光标下边创建新行，在新行中输入              |
|    `s`     | 删除光标后边的字符（盖住的字符），从删除的字符位置开始输入 |
| `I(大写i)` |                    从当前行行首开始输入                    |
|    `A`     |                    从当前行行尾开始输入                    |
|    `O`     |               从光标上边创建新行，新行中输入               |
|    `S`     |                删除当前行，在当前行开始输入                |





### 2.4 末行模式下的操作



> 从命令模式切换到末行模式只需要在键盘上输入一个 :，同时这个符号也会出现在窗口的最下端，这时候我们就可以在最后一行输入我们执行的命令了。
>
> 从末行模式切换回命令模式有两种方式：
>
> 1. 按两次 Esc
> 2. 在末行模式下执行一个完整指令，执行完毕，自动回到命令模式



* 保存退出

  | 末行模式下的命令 |          功能          |
  | :--------------: | :--------------------: |
  |       `q`        | 退出，没保存会提示保存 |
  |       `q!`       |    强制退出(不保存)    |
  |       `w`        |      保存，不退出      |
  |       `wq`       |        保存退出        |
  |       `x`        |        保存退出        |

  

* 替换

  >替换对应的命令是 `s` 并且可以给其指定参数，默认情况下只替换相关行的第一个满足条件的关键字， 如果需要整行替换需要加参数 `/g`
|                末行模式下的替换命令                 |                            说明                            |
| :-------------------------------------------------: | :--------------------------------------------------------: |
|        `s/` 被替换的关键字 / 新的关键字 `/g`        |                   只对光标所在行进行替换                   |
| 行号 1, 行号 2`s/` 被替换的关键字 / 新的关键字 `/g` | `[行号1 , 行号2]` 是一个从小到大的范围，对这个范围进行替换 |
|       `%s/` 被替换的关键字 / 新的关键字 `/g`        |                  `%` 代表对所有行进行替换                  |



### 2.5 分屏

| 末行模式下的替换命令 |              说明              |                备注                |
| :------------------: | :----------------------------: | :--------------------------------: |
|         `sp`         |   水平分屏，多个窗口垂直排列   |  多个窗口中显示同一个文件里的内容  |
|        `vsp`         |   垂直分屏，多个窗口水平排列   |  多个窗口中显示同一个文件里的内容  |
|       `ctrl+p`       |    光标在打开的屏幕之间切换    | 快捷键操作(按住 ctrl 然后按两次 w) |
|        `qall`        |        同时退出多个屏幕        |                                    |
|       `wqall`        |      同时保存退出多个屏幕      |                                    |
|     `sp 文件名`      | 分屏的同时指定打开的文件的名字 |   在新窗口中显示指定的文件的内容   |
|     `vsp 文件名`     | 分屏的同时指定打开的文件的名字 |   在新窗口中显示指定的文件的内容   |

除了在命令模式下分屏，我们也可以在使用 vim 打开文件的时候直接分屏，下边是需要用到的参数:

`-o`: 水平分屏
`-O`: 垂直分屏

```shell
# 在vim打开文件的时候指定打开多个文件和分屏方式
# 水平分屏
$ vim -o 文件1, 文件2, 文件3 ...
# 垂直分屏
$ vim -O 文件1, 文件2, 文件3 ...
```





## 3. Makefile

### 3.1  规则



```makefile
#每条规则的语法格式
target1,taget2...:depend1,depend2,...
	command
	....
	
```

`命令(command)`: 当前这条规则的动作，一般情况下这个动作就是一个shell命令

​				动作可一个是多个， `每个命令前必须有一个tab缩进并且独占一行`

`依赖(depend)`: 规则所必需的依赖条件，在规则的命令中可以使用这些依赖

​				例如：生成可执行文件的目标文件(`*.o`)可以作为依赖使用

`目标(target)`: 规则中的目标，这个目标和规则中的命令是对应的



**示例：**

```makefile
# 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app
################# 例1 #################
app:a.c b.c c.c
	gcc a.c b.c c.c -o app

################# 例2 #################
# 有多个目标, 多个依赖, 多个命令
app,app1:a.c b.c c.c d.c
	gcc a.c b.c -o app
	gcc c.c d.c -o app1
	
################# 例3 #################	
# 规则之间的嵌套
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# a.o 是第一条规则中的依赖
a.o:a.c
	gcc -c a.c
# b.o 是第一条规则中的依赖
b.o:b.c
	gcc -c b.c
# c.o 是第一条规则中的依赖
c.o:c.c
	gcc -c c.c

```



### 3.2 工作原理



#### 3.2.1 规则的执行

在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作

**示例：**

```makefile
# makefile
# 规则之间的嵌套
# 规则1
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# 规则2
a.o:a.c
	gcc -c a.c
# 规则3
b.o:b.c
	gcc -c b.c
# 规则4
c.o:c.c
	gcc -c c.c

```



>在这个例子中，如果执行 make 命令就会根据这个 makefile 中的 4 条规则编译这三个源文件。在解析第一条规则的时候发现里边的三个依赖都是不存在的，因此规则对应的命令也就不能被执行。
>
>当依赖不存在的时候，make 就是查找其他的规则，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则 2， 规则 3， 规则 4 里的命令会相继被执行，当规则 1 中依赖全部被生成之后对应的命令也就被执行了，因此规则 1 的目标被生成，make 工作结束。



> 如果想要执行 makefile 中非第一条规则对应的命令，那么就不能直接 make, 需要将那条规则的目标也写到 make 的后边，比如只需要执行规则 3 中的命令，就需要: make b.o。



#### 3.2.2 文件的时间戳

make 命令执行的时候会根据文件的时间戳判定是否执行 Makefile文件中相关规则中的命令。



#### 3.2.3 自动推导

假设有以下文件：

```shell
$ tree
.
├── add.c
├── div.c
├── head.h
├── main.c
├── makefile
├── mult.c
└── sub.c

```

Makefile

```makefile
# 这是一个完整的 makefile 文件
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc

```



执行make

```shell
$ make
cc    -c -o add.o add.c
cc    -c -o div.o div.c
cc    -c -o main.o main.c
cc    -c -o mult.o mult.c
cc    -c -o sub.o sub.c
gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
```



> 我们可以发现上边的 makefile 文件中只有一条规则，依赖中所有的 .o 文件在本地项目目录中是不存在的，并且也没有其他的规则用来生成这些依赖文件，这时候 make 会使用内部默认的构造规则先将这些依赖文件生成出来，然后在执行规则中的命令，最后生成目标文件 calc。





### 3.3 变量

使用 Makefile 进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile 中的变量分为三种：`自定义变量`，`预定义变量`和`自动变量`。



#### 3.3.1 自定义变量

> 用 Makefile 进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。makefile 中的变量是没有类型的，直接创建变量然后给其赋值就可以了。

**示例1**

```makefile
# 错误, 只创建了变量名, 没有赋值
变量名 
# 正确, 创建一个变量名并且给其赋值
变量名=变量值
```



**示例2**:变量的定义和使用

```makefile
# 如果将变量的值取出?
$(变量的名字)

# 举例 add.o  div.o  main.o  mult.o  sub.o
# 定义变量并赋值
obj=add.o  div.o  main.o  mult.o  sub.o
# 取变量的值
$(obj)
```



**示例3：** 

```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
$(target):$(obj)
        gcc  $(obj) -o $(target)

```



#### 3.3.2  预定义变量

在 Makefile 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：

|  变量名  |             含义             |  默认值  |
| :------: | :--------------------------: | :------: |
|    AR    |  生成静态库库文件的程序名称  |    ar    |
|    AS    |       汇编编译器的名称       |    as    |
|    CC    |      C 语言编译器的名称      |    cc    |
|   CPP    |     C 语言预编译器的名称     | $(CC) -E |
|   CXX    |     C++ 语言编译器的名称     |   g++    |
|    FC    |   FORTRAN 语言编译器的名称   |   f77    |
|    RM    |      删除文件程序的名称      |  rm -f   |
| ARFLAGS  |  生成静态库库文件程序的选项  | 无默认值 |
| ASFLAGS  |   汇编语言编译器的编译选项   | 无默认值 |
|  CFLAGS  |    C 语言编译器的编译选项    | 无默认值 |
| CPPFLAGS |    C 语言预编译的编译选项    | 无默认值 |
| CXXFLAGS |   C++ 语言编译器的编译选项   | 无默认值 |
|  FFLAGS  | FORTRAN 语言编译器的编译选项 | 无默认值 |



```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量和预定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
CFLAGS=-O3 # 代码优化
$(target):$(obj)
        $(CC)  $(obj) -o $(target) $(CFLAGS)
```



#### 3.3.3  自动化变量

Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。Makefile 中的规则语句中经常会出现目标文件和依赖文件，`自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。`

下表中是一些常见的自动变量

| 变量 | 含义                                                         |
| :--: | :----------------------------------------------------------- |
|  $*  | 表示目标文件的名称，不包含目标文件的扩展名                   |
|  $+  | 表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件 |
|  $<  | 表示依赖项中第一个依赖文件的名称                             |
|  $?  | 依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开 |
|  $@  | 表示目标文件的名称，包含文件扩展名                           |
|  $^  | 依赖项中，所有不重复的依赖文件，这些文件之间以空格分开       |



**示例：**

```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
# 使用自动变量, 替换相关的内容
calc:add.o  div.o  main.o  mult.o  sub.o
	gcc $^ -o $@ 			# 自动变量只能在规则的命令中使用
```





### 3.4 模式匹配

**示例：**

```makefile
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
# 语法格式重复的规则, 将 .c -> .o, 使用的命令都是一样的 gcc *.c -c
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c
```



**改写：**

```makefile
# 模式匹配 -> 通过一个公式, 代表若干个满足条件的规则
# 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名
%.o:%.c
	gcc $< -c
	
```



![image-20200418143747981](https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/20210702190648.png)





### 3.5 函数

makefile 中有很多函数并且`所有的函数都是有返回值的。`makefile 中函数的格式和 C/C++ 中函数也不同，其写法是这样的： `$(函数名 参数1, 参数2, 参数3, ...)`，主要目的是让我们能够快速方便的得到函数的返回值。

这里为大家介绍两个 makefile 中使用频率比较高的函数：`wildcard` 和 `patsubst`。



#### 3.5.1  wildcard

这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：

```makefile
# 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔
$(wildcard PATTERN...)
	参数:	指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c
```

参数功能：

​		PATTERN 指的是某个或多个目录下的对应的某种类型的文件，比如当前`目录下的.c` 文件可以写成 `*.c`

​		可以指定多个目录，每个路径之间使用空格间隔
返回值：

​		得到的若干个文件的文件列表， 文件名之间使用空格间隔
​		示例：`$(wildcard *.c ./sub/*.c)`
​				返回值格式: a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c

函数使用举例:

```makefile
# 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件
src = $(wildcard /home/robin/a/*.c /home/robin/b/*.c *.c)  # *.c == ./*.c
# 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔
/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c

```





#### 3.5.2  patsubst

这个函数的功能是按照指定的模式替换指定的文件名的后缀，函数原型如下:

```makefile
# 有三个参数, 参数之间使用 逗号间隔
$(patsubst <pattern>,<replacement>,<text>)
```

参数功能:
	pattern: 这是一个模式字符串，需要指定出要被替换的文件名中的后缀是什么
			文件名和路径不需要关心，因此使用 % 表示即可 [通配符是 %]
			在通配符后边指定出要被替换的后缀，比如: %.c, 意味着 .c 的后缀要被替换掉
replacement: 这是一个模式字符串，指定参数 pattern 中的后缀最终要被替换为什么
			还是使用 % 来表示参数 pattern 中文件的路径和名字
			在通配符 % 后边指定出新的后缀名，比如: %.o 这表示原来的后缀被替换为 .o
text: 该参数中存储这要被替换的原始数据
返回值:
			函数返回被替换过后的字符串。
函数使用举例:

```makefile
src = a.cpp b.cpp c.cpp e.cpp
# 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o
obj = $(patsubst %.cpp, %.o, $(src)) 
# obj 的值为: a.o b.o c.o e.o
```





### 3.6  实例

**文件：**

```shell
# 项目目录结构
.
├── add.c
├── div.c
├── head.h
├── main.c
├── mult.c
└── sub.c
# 需要编写makefile对该项目进行自动化编译
```



**Version1：**

```makefile
calc:add.c  div.c  main.c  mult.c  sub.c
        gcc add.c  div.c  main.c  mult.c  sub.c -o calc

```



**version2：**

```makefile
# 默认所有的依赖都不存在, 需要使用其他规则生成这些依赖
# 因为 add.o 被更新, 需要使用最新的依赖, 生成最新的目标
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc

# 如果修改了add.c, add.o 被重新生成
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c

```



**version3：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c
```



**version4：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
# % 匹配的内容是不能被替换的, 需要替换的是第一个参数中的后缀, 替换为第二个参数中指定的后缀
# obj=$(patsubst %.cpp, %.o, $(src)) 将src中的关键字 .cpp 替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c
```



**version5：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc
# obj 的值 xxx.o xxx.o xxx.o xx.o
$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c

# 添加规则, 删除生成文件 *.o 可执行程序
# 这个规则比较特殊, clean根本不会生成, 这是一个伪目标
clean:
        rm $(obj) $(target)
```



正常情况下这个版本的 makefile 是可以正常工作的，但是我们如果在这个项目目录中添加一个叫做 `clean` 的文件（和规则中的目标名称相同），再进行 `make clean` 发现这个规则就不能正常工作了。

```makefile
# 在项目目录中添加一个叫 clean的文件, 然后在 make clean 这个规则中的命令就不工作了
$ ls
add.c  calc   div.c  head.h  main.o    mult.c  sub.c
add.o  div.o  main.c  makefile  mult.o  sub.o  clean  ---> 新添加的

# 使用 makefile 中的规则删除生成的目标文件和可执行程序
$ make clean
make: 'clean' is up to date. 

# 查看目录, 发现相关文件并没有被删除, make clean 失败了
$ ls
add.c  calc   div.c  head.h  main.o    mult.c  sub.c
add.o  clean  div.o  main.c  makefile  mult.o  sub.o
```



**最终版：**

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c

# 添加规则, 删除生成文件 *.o 可执行程序
# 声明clean为伪文件
.PHONY:clean
clean:
        # shell命令前的 - 表示强制这个指令执行, 如果执行失败也不会终止
        -rm $(obj) $(target) 
        echo "hello, 我是测试字符串"

```







### 3.7 case

```shell
# 目录结构
.
├── include
│   └── head.h	==> 头文件, 声明了加减乘除四个函数
├── main.c		==> 测试程序, 调用了head.h中的函数
└── src
    ├── add.c	==> 加法运算
    ├── div.c	==> 除法运算
    ├── mult.c  ==> 乘法运算
    └── sub.c   ==> 减法运算
```



根据上边的项目目录结构编写的 makefile 文件如下:

```makefile
# 最终的目标名 app
target = app
# 搜索当前项目目录下的源文件
src=$(wildcard *.c ./src/*.c)
# 将文件的后缀替换掉 .c -> .o
obj=$(patsubst %.c, %.o, $(src))
# 头文件目录
include=./include

# 第一条规则
# 依赖中都是 xx.o yy.o zz.o
# gcc命令执行的是链接操作
$(target):$(obj)
        gcc $^ -o $@

# 模式匹配规则
# 执行汇编操作, 前两步: 预处理, 编译是自动完成
%.o:%.c
        gcc $< -c -I $(include) -o $@

# 添加一个清除文件的规则
.PHONY:clean

clean:
        -rm $(obj) $(target) -f
```





## 4. GDB





